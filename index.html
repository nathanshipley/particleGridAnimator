<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Grid Animator</title>
    <style>
        /* Scoped styles for Squarespace compatibility */
        .particle-animator-container {
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            color: #333;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .particle-animator-container * {
            box-sizing: border-box;
        }
        
        /* Header Styles */
        .particle-animator-header {
            background: #2c3e50;
            color: white;
            padding: 30px 20px;
            text-align: left;
            margin-bottom: 20px;
        }
        
        .particle-animator-header h1 {
            margin: 0 0 10px 0;
            font-size: 32px;
            font-weight: 600;
            color: white;
        }
        
        .particle-animator-header .attribution {
            margin: 0 0 20px 0;
            font-size: 16px;
            color: #ecf0f1;
        }
        
        .particle-animator-header .attribution a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .particle-animator-header .attribution a:hover {
            color: #5dade2;
            text-decoration: underline;
        }
        
        .particle-animator-header .description {
            max-width: 800px;
            line-height: 1.6;
        }
        
        .particle-animator-header .description p {
            margin: 0 0 10px 0;
            color: #ecf0f1;
        }
        
        .particle-animator-header .description strong {
            color: white;
        }
        
        .particle-animator-header .description a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .particle-animator-header .description a:hover {
            color: #5dade2;
            text-decoration: underline;
        }
        
        /* Main Content Area */
        .particle-animator-main {
            display: flex;
            gap: 20px;
            padding: 0 20px 20px;
        }
        
        .particle-animator-container #visualizerContainer {
            flex: 1;
            min-width: 0;
        }
        
        .particle-animator-container #canvasContainer {
            background: #000;
            border: 1px solid #ddd;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 720px;
            margin: 0 auto;
        }
        
        .particle-animator-container canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        
        .particle-animator-container #playbackControls {
            background: #fff;
            padding: 15px;
            margin-top: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .particle-animator-container #timelineContainer {
            background: #fff;
            padding: 20px;
            margin-top: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 720px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .particle-animator-container #controls {
            flex: 0 0 300px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .particle-animator-container .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .particle-animator-container .control-group:last-child {
            border-bottom: none;
        }
        
        .particle-animator-container h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #333;
        }
        
        .particle-animator-container h3 {
            margin: 15px 0 10px 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .particle-animator-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }
        
        .particle-animator-container input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .particle-animator-container input[type="number"] {
            width: 100%;
            padding: 5px;
            background: #f8f8f8;
            border: 1px solid #ddd;
            color: #333;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .particle-animator-container button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background 0.2s;
        }
        
        .particle-animator-container button:hover {
            background: #357abd;
        }
        
        .particle-animator-container button:active {
            transform: translateY(1px);
        }
        
        .particle-animator-container button.small {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .particle-animator-container .value-display {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
        }
        
        .particle-animator-container #info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .particle-animator-container .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .particle-animator-container input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .particle-animator-container input[type="color"] {
            width: 100%;
            height: 40px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        
        /* Timeline Styles */
        .particle-animator-container .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .particle-animator-container .timeline-track {
            margin-bottom: 15px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 5px;
        }
        
        .particle-animator-container .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 0 5px;
        }
        
        .particle-animator-container .track-name {
            font-size: 12px;
            font-weight: 600;
            color: #555;
        }
        
        .particle-animator-container .track-controls {
            display: flex;
            gap: 5px;
        }
        
        .particle-animator-container .timeline-ruler {
            height: 30px;
            background: #333;
            border-radius: 3px;
            position: relative;
            margin-bottom: 10px;
            cursor: pointer;
        }
        
        .particle-animator-container .timeline-numbers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 5px;
            color: #fff;
            font-size: 10px;
            pointer-events: none;
        }
        
        .particle-animator-container .timeline-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff0000;
            cursor: ew-resize;
            z-index: 10;
        }
        
        .particle-animator-container .timeline-playhead::after {
            content: attr(data-frame);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #ff0000;
            color: white;
            padding: 2px 6px;
            font-size: 11px;
            border-radius: 3px;
            white-space: nowrap;
            margin-bottom: 2px;
        }
        
        .particle-animator-container .keyframe-track {
            height: 30px;
            background: #f0f0f0;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }
        
        .particle-animator-container .keyframe {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #4a90e2;
            border: 2px solid #fff;
            border-radius: 2px;
            cursor: move;
            transition: transform 0.1s;
            z-index: 5;
        }
        
        .particle-animator-container .keyframe:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .particle-animator-container .keyframe.selected {
            background: #ff6b6b;
        }
        
        /* Export Modal */
        .particle-animator-container #exportModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        
        .particle-animator-container #exportContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .particle-animator-container #exportContent h3 {
            margin-top: 0;
            color: #333;
        }
        
        .particle-animator-container #exportTextarea {
            width: 100%;
            height: 400px;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ddd;
            padding: 10px;
            resize: vertical;
        }
        
        .particle-animator-container #exportButtons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        /* Responsive adjustments for smaller desktops */
        @media (max-width: 1200px) {
            .particle-animator-main {
                flex-direction: column;
            }
            
            .particle-animator-container #controls {
                flex: 1;
                max-width: 100%;
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="particle-animator-container">
        <div class="particle-animator-header">
            <h1>Particle Grid Animator</h1>
            <p class="attribution">by <a href="https://www.nathanshipley.com/" target="_blank">Nathan Shipley</a></p>
            <div class="description">
                <p>Create simple particle animations with wave motion, Perlin noise, and random effects.</p>
                <p><strong>How to use:</strong> Adjust the grid size and particle settings in the controls panel. Enable different animation effects and use the sliders to control their intensity. Add keyframes to create evolving animations over time. Click the timeline to scrub through your animation.</p>
                <p>The JSON exported data is formatted to work as Tracks with Kijai's <a href="https://github.com/kijai/ComfyUI-WanVideoWrapper/blob/main/example_workflows/wanvideo_ATI_testing_01.json" target="_blank">ATI implementation</a> for Wan in ComfyUI.</p>
            </div>
        </div>
        
        <div class="particle-animator-main">
            <div id="visualizerContainer">
            <div id="canvasContainer">
                <canvas id="canvas"></canvas>
                <div id="info">Frame: <span id="frameCount">0</span> / <span id="totalFrames">120</span></div>
            </div>
            <div id="playbackControls">
                <button onclick="togglePlayback()">Play/Pause</button>
                <button onclick="resetAnimation()">Reset</button>
                <button onclick="exportJSON()">Export JSON</button>
            </div>
            <div id="timelineContainer">
                <div class="timeline-header">
                    <h3>Timeline</h3>
                    <button class="small" onclick="clearAllKeyframes()">Clear All</button>
                </div>
                <div class="timeline-ruler" id="timelineRuler">
                    <div class="timeline-numbers"></div>
                    <div class="timeline-playhead" id="playhead" data-frame="0"></div>
                </div>
                <div id="timelineTracks"></div>
            </div>
        </div>
        
        <div id="controls">
            <div class="control-group">
                <h2>Canvas Settings</h2>
                <label>Width: <input type="number" id="canvasWidth" value="720" min="100" max="2000"></label>
                <label>Height: <input type="number" id="canvasHeight" value="720" min="100" max="2000"></label>
                <label>Duration (seconds): <input type="number" id="duration" value="5" min="0.1" max="30" step="0.1"></label>
                <label>FPS: <input type="number" id="fps" value="24" min="1" max="60"></label>
                <button onclick="updateCanvasSettings()">Apply Settings</button>
            </div>
            
            <div class="control-group">
                <h2>Particle Grid</h2>
                <label>Grid Size X: <span class="value-display" id="gridXValue">20</span></label>
                <input type="range" id="gridX" min="2" max="50" value="20" oninput="updateGrid()">
                
                <label>Grid Size Y: <span class="value-display" id="gridYValue">20</span></label>
                <input type="range" id="gridY" min="2" max="50" value="20" oninput="updateGrid()">
                
                <label>Particle Size: <span class="value-display" id="particleSizeValue">3</span></label>
                <input type="range" id="particleSize" min="1" max="20" value="3" step="0.5">
            </div>
            
            <div class="control-group">
                <h2>Colors</h2>
                <label>Background Color:</label>
                <input type="color" id="backgroundColor" value="#5a6a72">
                
                <label>Particle Color:</label>
                <input type="color" id="particleColor" value="#ffe4bd">
            </div>
            
            <div class="control-group">
                <h2>Animation Effects</h2>
                
                <h3>Wave Motion</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="waveEnabled" checked>
                    <label for="waveEnabled">Enable Wave</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="waveLoop">
                    <label for="waveLoop">Loop Wave</label>
                </div>
                <label>Wave Amplitude: <span class="value-display" id="waveAmpValue">50</span></label>
                <input type="range" id="waveAmp" min="0" max="200" value="50">
                
                <label>Wave Frequency: <span class="value-display" id="waveFreqValue">2</span></label>
                <input type="range" id="waveFreq" min="0.1" max="10" value="2" step="0.1">
                
                <label>Wave Speed: <span class="value-display" id="waveSpeedValue">1</span></label>
                <input type="range" id="waveSpeed" min="0" max="5" value="1" step="0.1">
                
                <h3>Perlin Noise</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="noiseEnabled" checked>
                    <label for="noiseEnabled">Enable Noise</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="noiseLoop">
                    <label for="noiseLoop">Loop Noise</label>
                </div>
                <label>Noise Scale: <span class="value-display" id="noiseScaleValue">0.01</span></label>
                <input type="range" id="noiseScale" min="0.001" max="0.1" value="0.01" step="0.001">
                
                <label>Noise Strength: <span class="value-display" id="noiseStrengthValue">30</span></label>
                <input type="range" id="noiseStrength" min="0" max="100" value="30">
                
                <label>Noise Speed: <span class="value-display" id="noiseSpeedValue">0.5</span></label>
                <input type="range" id="noiseSpeed" min="0" max="2" value="0.5" step="0.1">
                
                <h3>Random Motion</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="randomEnabled">
                    <label for="randomEnabled">Enable Random</label>
                </div>
                <label>Random Strength: <span class="value-display" id="randomStrengthValue">10</span></label>
                <input type="range" id="randomStrength" min="0" max="50" value="10">
            </div>
        </div>
        
        <div id="exportModal">
            <div id="exportContent">
                <h3>Export Animation Data</h3>
                <textarea id="exportTextarea" readonly></textarea>
                <div id="exportButtons">
                    <button onclick="copyToClipboard()">Copy to Clipboard</button>
                    <button onclick="downloadJSON()">Download as File</button>
                    <button onclick="closeExportModal()">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Wrap in IIFE to avoid global scope conflicts in Squarespace
        (function() {
            // Perlin noise implementation
            class PerlinNoise {
                constructor() {
                    this.p = [];
                    for (let i = 0; i < 256; i++) {
                        this.p[i] = Math.floor(Math.random() * 256);
                    }
                    for (let i = 0; i < 256; i++) {
                        this.p[256 + i] = this.p[i];
                    }
                }
                
                fade(t) {
                    return t * t * t * (t * (t * 6 - 15) + 10);
                }
                
                lerp(t, a, b) {
                    return a + t * (b - a);
                }
                
                grad(hash, x, y) {
                    const h = hash & 3;
                    const u = h < 2 ? x : y;
                    const v = h < 2 ? y : x;
                    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
                }
                
                noise(x, y) {
                    const X = Math.floor(x) & 255;
                    const Y = Math.floor(y) & 255;
                    
                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    
                    const u = this.fade(x);
                    const v = this.fade(y);
                    
                    const a = this.p[X] + Y;
                    const aa = this.p[a];
                    const ab = this.p[a + 1];
                    const b = this.p[X + 1] + Y;
                    const ba = this.p[b];
                    const bb = this.p[b + 1];
                    
                    return this.lerp(v,
                        this.lerp(u, this.grad(this.p[aa], x, y), this.grad(this.p[ba], x - 1, y)),
                        this.lerp(u, this.grad(this.p[ab], x, y - 1), this.grad(this.p[bb], x - 1, y - 1))
                    );
                }
            }
            
            // Keyframe system
            class KeyframeTrack {
                constructor(name, paramId, min, max) {
                    this.name = name;
                    this.paramId = paramId;
                    this.min = min;
                    this.max = max;
                    this.keyframes = [];
                }
                
                addKeyframe(time, value) {
                    // Remove any existing keyframe at this time
                    this.keyframes = this.keyframes.filter(kf => Math.abs(kf.time - time) > 0.01);
                    this.keyframes.push({ time, value });
                    this.keyframes.sort((a, b) => a.time - b.time);
                }
                
                removeKeyframe(index) {
                    this.keyframes.splice(index, 1);
                }
                
                getValueAtTime(time) {
                    if (this.keyframes.length === 0) {
                        return parseFloat(document.getElementById(this.paramId).value);
                    }
                    
                    if (time <= this.keyframes[0].time) {
                        return this.keyframes[0].value;
                    }
                    
                    if (time >= this.keyframes[this.keyframes.length - 1].time) {
                        return this.keyframes[this.keyframes.length - 1].value;
                    }
                    
                    // Find surrounding keyframes
                    for (let i = 0; i < this.keyframes.length - 1; i++) {
                        if (time >= this.keyframes[i].time && time <= this.keyframes[i + 1].time) {
                            const k1 = this.keyframes[i];
                            const k2 = this.keyframes[i + 1];
                            const t = (time - k1.time) / (k2.time - k1.time);
                            return k1.value + (k2.value - k1.value) * t; // Linear interpolation
                        }
                    }
                    
                    return this.keyframes[0].value;
                }
            }
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const perlin = new PerlinNoise();
            
            let canvasWidth = 720;
            let canvasHeight = 720;
            let duration = 5;
            let fps = 24;
            let totalFrames = duration * fps;
            let currentFrame = 0;
            let isPlaying = false;
            let particles = [];
            let animationData = [];
            let animationId = null;
            let lastTime = 0;
            let frameTime = 1000 / 24; // milliseconds per frame at 24 FPS
            
            // Keyframe tracks
            const keyframeTracks = [
                new KeyframeTrack('Wave Amplitude', 'waveAmp', 0, 200),
                new KeyframeTrack('Wave Frequency', 'waveFreq', 0.1, 10),
                new KeyframeTrack('Wave Speed', 'waveSpeed', 0, 5),
                new KeyframeTrack('Noise Strength', 'noiseStrength', 0, 100),
                new KeyframeTrack('Noise Scale', 'noiseScale', 0.001, 0.1),
                new KeyframeTrack('Noise Speed', 'noiseSpeed', 0, 2),
                new KeyframeTrack('Random Strength', 'randomStrength', 0, 50)
            ];
            
            class Particle {
                constructor(x, y, index) {
                    this.baseX = x;
                    this.baseY = y;
                    this.x = x;
                    this.y = y;
                    this.index = index;
                    this.randomOffsetX = Math.random() * Math.PI * 2;
                    this.randomOffsetY = Math.random() * Math.PI * 2;
                }
                
                update(frame) {
                    const t = frame / totalFrames;
                    const time = t * duration;
                    
                    // Reset to base position
                    this.x = this.baseX;
                    this.y = this.baseY;
                    
                    // Get animated values from keyframe tracks
                    const waveAmp = keyframeTracks[0].getValueAtTime(time);
                    const waveFreq = keyframeTracks[1].getValueAtTime(time);
                    const waveSpeed = keyframeTracks[2].getValueAtTime(time);
                    const noiseStrength = keyframeTracks[3].getValueAtTime(time);
                    const noiseScale = keyframeTracks[4].getValueAtTime(time);
                    const noiseSpeed = keyframeTracks[5].getValueAtTime(time);
                    const randomStrength = keyframeTracks[6].getValueAtTime(time);
                    
                    // Wave motion
                    if (document.getElementById('waveEnabled').checked) {
                        const waveLoop = document.getElementById('waveLoop').checked;
                        
                        if (waveLoop) {
                            // Looping wave: ensures seamless loop by using full cycles
                            const cycles = Math.floor(waveSpeed); // Number of complete cycles
                            const adjustedSpeed = cycles > 0 ? cycles : 1; // At least 1 cycle
                            
                            const waveX = Math.sin((this.baseY / canvasHeight) * Math.PI * waveFreq + t * adjustedSpeed * Math.PI * 2) * waveAmp;
                            const waveY = Math.sin((this.baseX / canvasWidth) * Math.PI * waveFreq + t * adjustedSpeed * Math.PI * 2) * waveAmp * 0.5;
                            
                            this.x += waveX;
                            this.y += waveY;
                        } else {
                            // Non-looping wave: continuous progression
                            const waveX = Math.sin((this.baseY / canvasHeight) * Math.PI * waveFreq + time * waveSpeed * Math.PI * 2) * waveAmp;
                            const waveY = Math.sin((this.baseX / canvasWidth) * Math.PI * waveFreq + time * waveSpeed * Math.PI * 2) * waveAmp * 0.5;
                            
                            this.x += waveX;
                            this.y += waveY;
                        }
                    }
                    
                    // Perlin noise
                    if (document.getElementById('noiseEnabled').checked) {
                        const noiseLoop = document.getElementById('noiseLoop').checked;
                        
                        let noiseTime = time * noiseSpeed;
                        
                        // If looping is enabled, create seamless loop
                        if (noiseLoop) {
                            const loopProgress = t; // 0 to 1 over the animation
                            const angle = loopProgress * Math.PI * 2;
                            
                            // Use circular interpolation for seamless looping
                            const radius = noiseSpeed;
                            const timeX = Math.cos(angle) * radius;
                            const timeY = Math.sin(angle) * radius;
                            
                            const noiseX = perlin.noise(
                                this.baseX * noiseScale + timeX,
                                this.baseY * noiseScale + timeY
                            ) * noiseStrength;
                            
                            const noiseY = perlin.noise(
                                this.baseX * noiseScale + 100 + timeX,
                                this.baseY * noiseScale + 100 + timeY
                            ) * noiseStrength;
                            
                            this.x += noiseX;
                            this.y += noiseY;
                        } else {
                            // Regular non-looping noise
                            const noiseX = perlin.noise(
                                this.baseX * noiseScale,
                                this.baseY * noiseScale + noiseTime
                            ) * noiseStrength;
                            
                            const noiseY = perlin.noise(
                                this.baseX * noiseScale + 100,
                                this.baseY * noiseScale + noiseTime
                            ) * noiseStrength;
                            
                            this.x += noiseX;
                            this.y += noiseY;
                        }
                    }
                    
                    // Random motion
                    if (document.getElementById('randomEnabled').checked) {
                        const randomX = Math.sin(time * 3 + this.randomOffsetX) * randomStrength;
                        const randomY = Math.cos(time * 2 + this.randomOffsetY) * randomStrength;
                        
                        this.x += randomX;
                        this.y += randomY;
                    }
                }
                
                draw() {
                    const size = parseFloat(document.getElementById('particleSize').value);
                    const color = document.getElementById('particleColor').value;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            window.updateCanvasSettings = function() {
                canvasWidth = parseInt(document.getElementById('canvasWidth').value);
                canvasHeight = parseInt(document.getElementById('canvasHeight').value);
                duration = parseFloat(document.getElementById('duration').value);
                fps = parseInt(document.getElementById('fps').value);
                totalFrames = Math.floor(duration * fps);
                frameTime = 1000 / fps;
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                document.getElementById('totalFrames').textContent = totalFrames;
                
                updateGrid();
                resetAnimation();
                updateTimeline();
            }
            
            window.updateGrid = function() {
                const gridX = parseInt(document.getElementById('gridX').value);
                const gridY = parseInt(document.getElementById('gridY').value);
                
                document.getElementById('gridXValue').textContent = gridX;
                document.getElementById('gridYValue').textContent = gridY;
                
                particles = [];
                const spacingX = canvasWidth / (gridX + 1);
                const spacingY = canvasHeight / (gridY + 1);
                
                let index = 0;
                for (let y = 0; y < gridY; y++) {
                    for (let x = 0; x < gridX; x++) {
                        const px = spacingX * (x + 1);
                        const py = spacingY * (y + 1);
                        particles.push(new Particle(px, py, index++));
                    }
                }
                
                render();
            }
            
            function render() {
                const bgColor = document.getElementById('backgroundColor').value;
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                particles.forEach(particle => {
                    particle.update(currentFrame);
                    particle.draw();
                });
                
                document.getElementById('frameCount').textContent = currentFrame;
                updatePlayhead();
            }
            
            function animate(timestamp) {
                if (isPlaying) {
                    if (!lastTime) lastTime = timestamp;
                    
                    const deltaTime = timestamp - lastTime;
                    
                    // Update frame based on actual FPS
                    if (deltaTime >= frameTime) {
                        currentFrame = (currentFrame + 1) % totalFrames;
                        render();
                        lastTime = timestamp - (deltaTime % frameTime);
                    }
                    
                    animationId = requestAnimationFrame(animate);
                }
            }
            
            window.togglePlayback = function() {
                isPlaying = !isPlaying;
                if (isPlaying) {
                    lastTime = 0;
                    animate(0);
                } else {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                }
            }
            
            window.resetAnimation = function() {
                currentFrame = 0;
                isPlaying = false;
                lastTime = 0;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                render();
            }
            
            window.exportJSON = function() {
                const particleData = [];
                
                // For each particle, collect all its positions across all frames
                particles.forEach((particle, particleIndex) => {
                    const particleFrames = [];
                    
                    // Collect this particle's position for each frame
                    for (let frame = 0; frame < totalFrames; frame++) {
                        particle.update(frame);
                        particleFrames.push({
                            x: Math.round(particle.x),
                            y: Math.round(particle.y)
                        });
                    }
                    
                    particleData.push(particleFrames);
                });
                
                // Display the JSON in the modal
                const jsonData = JSON.stringify(particleData);
                document.getElementById('exportTextarea').value = jsonData;
                document.getElementById('exportModal').style.display = 'block';
                
                // Reset to current frame after export
                render();
            }
            
            window.closeExportModal = function() {
                document.getElementById('exportModal').style.display = 'none';
            }
            
            window.copyToClipboard = function() {
                const textarea = document.getElementById('exportTextarea');
                textarea.select();
                document.execCommand('copy');
                
                // Visual feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }
            
            window.downloadJSON = function() {
                const jsonData = document.getElementById('exportTextarea').value;
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'particle_animation.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // Timeline functions
            function updateTimeline() {
                const ruler = document.querySelector('.timeline-numbers');
                ruler.innerHTML = '';
                
                // Add time markers
                for (let i = 0; i <= 5; i++) {
                    const time = (duration * i / 5).toFixed(1) + 's';
                    const marker = document.createElement('span');
                    marker.textContent = time;
                    ruler.appendChild(marker);
                }
                
                renderTimelineTracks();
            }
            
            function renderTimelineTracks() {
                const container = document.getElementById('timelineTracks');
                container.innerHTML = '';
                
                keyframeTracks.forEach((track, trackIndex) => {
                    const trackDiv = document.createElement('div');
                    trackDiv.className = 'timeline-track';
                    
                    const header = document.createElement('div');
                    header.className = 'track-header';
                    
                    const name = document.createElement('div');
                    name.className = 'track-name';
                    name.textContent = track.name;
                    
                    const controls = document.createElement('div');
                    controls.className = 'track-controls';
                    
                    const addBtn = document.createElement('button');
                    addBtn.className = 'small';
                    addBtn.textContent = 'Add Key';
                    addBtn.onclick = () => addKeyframeAtCurrentTime(trackIndex);
                    
                    controls.appendChild(addBtn);
                    header.appendChild(name);
                    header.appendChild(controls);
                    
                    const keyframeTrack = document.createElement('div');
                    keyframeTrack.className = 'keyframe-track';
                    keyframeTrack.dataset.trackIndex = trackIndex;
                    
                    // Add keyframes
                    track.keyframes.forEach((kf, kfIndex) => {
                        const keyframe = document.createElement('div');
                        keyframe.className = 'keyframe';
                        keyframe.style.left = (kf.time / duration * 100) + '%';
                        keyframe.dataset.keyframeIndex = kfIndex;
                        keyframe.title = `Time: ${kf.time.toFixed(2)}s, Value: ${kf.value.toFixed(2)}`;
                        
                        keyframe.onmousedown = (e) => startDragKeyframe(e, trackIndex, kfIndex);
                        keyframe.oncontextmenu = (e) => {
                            e.preventDefault();
                            track.removeKeyframe(kfIndex);
                            renderTimelineTracks();
                            render();
                        };
                        
                        keyframeTrack.appendChild(keyframe);
                    });
                    
                    trackDiv.appendChild(header);
                    trackDiv.appendChild(keyframeTrack);
                    container.appendChild(trackDiv);
                });
            }
            
            function updatePlayhead() {
                const playhead = document.getElementById('playhead');
                const progress = currentFrame / totalFrames;
                playhead.style.left = (progress * 100) + '%';
                playhead.setAttribute('data-frame', `Frame ${currentFrame}`);
            }
            
            let isDraggingPlayhead = false;
            
            function initializeTimelineControls() {
                const ruler = document.getElementById('timelineRuler');
                const playhead = document.getElementById('playhead');
                
                // Click on ruler to seek
                ruler.addEventListener('click', function(e) {
                    if (e.target === playhead || isDraggingPlayhead) return;
                    seekToPosition(e);
                });
                
                // Drag playhead
                playhead.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    isDraggingPlayhead = true;
                    document.addEventListener('mousemove', dragPlayhead);
                    document.addEventListener('mouseup', stopDragPlayhead);
                });
            }
            
            function dragPlayhead(e) {
                const ruler = document.getElementById('timelineRuler');
                const rect = ruler.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const progress = Math.max(0, Math.min(1, x / rect.width));
                currentFrame = Math.floor(progress * totalFrames);
                render();
            }
            
            function stopDragPlayhead() {
                isDraggingPlayhead = false;
                document.removeEventListener('mousemove', dragPlayhead);
                document.removeEventListener('mouseup', stopDragPlayhead);
            }
            
            function seekToPosition(event) {
                const rect = event.currentTarget.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const progress = Math.max(0, Math.min(1, x / rect.width));
                currentFrame = Math.floor(progress * totalFrames);
                render();
            }
            
            window.addKeyframeAtCurrentTime = function(trackIndex) {
                const track = keyframeTracks[trackIndex];
                const currentTime = (currentFrame / totalFrames) * duration;
                const currentValue = parseFloat(document.getElementById(track.paramId).value);
                
                track.addKeyframe(currentTime, currentValue);
                renderTimelineTracks();
                render();
            }
            
            let draggedKeyframe = null;
            let dragTrackIndex = null;
            
            function startDragKeyframe(e, trackIndex, keyframeIndex) {
                e.preventDefault();
                draggedKeyframe = keyframeIndex;
                dragTrackIndex = trackIndex;
                
                document.addEventListener('mousemove', dragKeyframe);
                document.addEventListener('mouseup', stopDragKeyframe);
            }
            
            function dragKeyframe(e) {
                if (draggedKeyframe === null) return;
                
                const track = keyframeTracks[dragTrackIndex];
                const trackElement = document.querySelector(`[data-track-index="${dragTrackIndex}"]`);
                const rect = trackElement.getBoundingClientRect();
                
                const x = e.clientX - rect.left;
                const progress = Math.max(0, Math.min(1, x / rect.width));
                const newTime = progress * duration;
                
                const kf = track.keyframes[draggedKeyframe];
                kf.time = newTime;
                
                track.keyframes.sort((a, b) => a.time - b.time);
                renderTimelineTracks();
                render();
            }
            
            function stopDragKeyframe() {
                draggedKeyframe = null;
                dragTrackIndex = null;
                document.removeEventListener('mousemove', dragKeyframe);
                document.removeEventListener('mouseup', stopDragKeyframe);
            }
            
            window.clearAllKeyframes = function() {
                keyframeTracks.forEach(track => track.keyframes = []);
                renderTimelineTracks();
                render();
            }
            
            // Update value displays
            document.querySelectorAll('input[type="range"]').forEach(input => {
                input.addEventListener('input', function() {
                    const valueDisplay = document.getElementById(this.id + 'Value');
                    if (valueDisplay) {
                        valueDisplay.textContent = this.value;
                    }
                    if (!this.id.includes('grid')) {
                        render();
                    }
                });
            });
            
            document.querySelectorAll('input[type="checkbox"]').forEach(input => {
                input.addEventListener('change', render);
            });
            
            document.getElementById('backgroundColor').addEventListener('change', render);
            document.getElementById('particleColor').addEventListener('change', render);
            
            // Initialize
            updateCanvasSettings();
            initializeTimelineControls();
        })();
    </script>
</body>
</html>